# Archivo docker-compose que comienza con la versión.
# Utilizamos "3.9" ya que es la versión más reciente en el momento de escribir esto
version: '3.9'

# Es importante entender que docker-compose trabaja con servicios.
# 1 servicio = 1 contenedor.
# Un servicio puede ser un sistema de gestión de contenido, un servidor, un servidor de bases de datos...
# La sección donde se describirán los servicios comienza con 'services'
services:
  mariadb:
    # Nombre del contenedor
    container_name: mariadb
    # La palabra clave "build" permite especificar
    # la ruta al archivo Dockerfile que se debe utilizar para crear la imagen,
    # que permitirá ejecutar el servicio.
    # Aquí, './requirements/mariadb' se corresponde con la ruta a la carpeta mariadb,
    # que contiene el Dockerfile correspondiente
    build: ./requirements/mariadb
    # Este parámetro define la política de reinicio del contenedor
    restart: always
    # Este parámetro indica a Compose que deseamos agregar variables de entorno desde el archivo .env,
    # que se encuentra en el contexto de compilación.
    # En este caso, el contexto de compilación es nuestro directorio actual.
    env_file: .env
    # Aquí montamos un volumen nombrado llamado db en el directorio /var/lib/mysql dentro del contenedor.
    # Esta es la ubicación estándar de datos en la mayoría de las distribuciones.
    volumes:
      - db:/var/lib/mysql
    # Este parámetro indica que el servicio del contenedor se conectará a la red llamada project,
    # que definiremos más abajo en el archivo.
    networks:
      - project

  wordpress:
    container_name: wordpress
    build: ./requirements/wordpress
    env_file: .env
    # Montamos un volumen llamado wp en el punto de montaje /var/www/html/wordpress,
    # que es creado por la imagen de WordPress.
    # Usar un volumen con este nombre nos permite compartir el código de nuestra aplicación con otros contenedores.
    volumes:
      - wp:/var/www/html/wordpress
    # Agregamos el contenedor de WordPress a la red llamada project.
    networks:
      - project
    # Este parámetro garantiza que nuestros contenedores se inicien en el orden de dependencia.
    # El contenedor de WordPress se inicia después del contenedor de mariadb,
    # ya que nuestra aplicación WordPress depende de la base de datos y el usuario.
    depends_on:
      - mariadb

  nginx:
    container_name: nginx
    build: ./requirements/nginx
    hostname: localhost
    volumes:
      - wp:/var/www/html/wordpress
    networks:
      - project
    depends_on:
      - wordpress
    # Recuerda que en el servicio 'nginx' el puerto 443 está configurado.
    # Si queremos acceder al servidor desde nuestra computadora (fuera del contenedor),
    # necesitamos redirigir este puerto al puerto de nuestra computadora.
    # Para esto, usamos la palabra clave 'ports' de la siguiente manera: [puerto de la computadora]:[puerto del contenedor]
    # En nuestro caso, queremos usar el puerto 443 de la computadora y vincularlo al puerto 443 del contenedor,
    # que es el puerto donde el servidor espera las solicitudes.
    ports:
      # - "8080:80" # http
      - "443:443" # https

  redis:
    build: ./requirements/bonus/redis
    container_name: redis
    ports:
      - "6379:6379"
    networks:
      - project
    restart: always

  ftp-server:
    build: ./requirements/bonus/ftp-server
    container_name: ftp-server
    ports:
      - "21:21"
      - "21100-21110:21100-21110"
    volumes:
      - wp:/var/www/html/wordpress
    networks:
     - project
    restart: always
    environment:
      FTP_USR: ${FTP_USR}
      FTP_PWD: ${FTP_PWD}

  portainer:
    container_name: portainer
    build: ./requirements/bonus/portainer/
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - prt:/data
    restart: always
    networks:
      - project
    ports:
      - "9443:9443"
  #portainer:
  #  image: portainer/portainer-ce:latest
  #  container_name: portainer
  #  ports:
  #    - "8000:8000"
  #    - "9443:9443"
  #  volumes:
  #    - "/etc/localtime:/etc/localtime:ro"
  #    - "/var/run/docker.sock:/var/run/docker.sock:ro"
  #  security_opt:
  #    - no-new-privileges:true
  #  restart: always

  # adminer - se inicia solo cuando es necesario - omite nginx
  adminer:
    container_name: adminer
    build: ./requirements/bonus/adminer/
    image: adminer:42
    depends_on:
      - mariadb
    ports:
      - "9000:8080"
    networks:
      - project
    restart: unless-stopped

  #adminer:
  #  image: adminer:4
  #  container_name: adminer
  #  restart: unless-stopped
  #  networks:
  #    - project
  #  depends_on:
  #    - mariadb
  #  ports:
  #    - "9000:8080"

  site:
    container_name: site
    build: ./requirements/bonus/site/
    restart: always
    networks:
      - project
    depends_on:
      - nginx
    ports:
      - "1111:1111"

# Nuestro nivel superior de claves 'volumes' define los volúmenes 'db' y 'wp'.
# Cuando Docker crea volúmenes, el contenido del volumen se guarda en el directorio del sistema de archivos del host,
# en /var/lib/docker/volumes/, y este proceso está gestionado por Docker.
# Luego, el contenido de cada volumen se monta desde este directorio en cualquier contenedor que use el volumen.
# De esta manera, podemos compartir código y datos entre contenedores.
volumes:
  db:
    name: db
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/${USER}/data/db
  wp:
    name: wp
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/${USER}/data/wp
  prt:
    name: prt
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/${USER}/data/prt

# El sistema de red 'project' creado por el usuario permite la comunicación entre nuestros contenedores,
# ya que están en el mismo host del demonio de Docker.
# Esto permite organizar el tráfico y la comunicación dentro de la aplicación,
# ya que abre todos los puertos entre contenedores en una red de puente, ocultando los puertos del mundo exterior.
# De esta manera, nuestros contenedores mariadb, wordpress y nginx pueden interactuar entre sí,
# y solo necesitaremos abrir el puerto 440 para el acceso externo a la aplicación.
networks:
  project:
    driver: bridge